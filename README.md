# Cities
Задачка с собеседования.

На собеседовании получил задачку, но сходу решить не смог. 
Не хватило мне нервов и сосредооточенности. Обычно я сначала некоторое время хожу, 
обдумываю как лучше сделать тот или иной алгоритм и не берусь его писать сходу,
а там пришлось с лёту начинать писать. Короче - немного я там накосячил.

Вот одним вечером решил переписать алгоритм, немного подумал и сделал несколько 
вариантов на базе очереди.

Все возможные алгоритмы поиска пути из одной точки в другую через промежуточные 
точки. Есть варианты оптимизированные, есть не оптимальные.

> one_way(cities=cities, start='A', finish='D') - возвращает один любой путь,
    в виде списка исходных направлений (точка старта + точка финиша для каждого
    отрезка в форме неизменяемых списков). Движение одностороннее.
    
> multiway - возвращает все возможные пути аналогично one_way.

> any_way - возвращает один любой путь, но движение рассматривается как
    двухстороннее. Нет разници от старта к финишу двигаться или от финиша к
    старту.

> any_multiway - все возможные пути аналогичные any_way.

> one_way_optimal(cities=cities, start='A', finish='D') - возвращает один
    любой путь, в виде списка точек: старта, промежуточные точки, финиша.
    Движение одностороннее, промежуточные точки не повторяются.

> multiway_optimal - возвращает все возможные пути аналогично one_way_optimal

> any_way_optimal - возвращает один любой путь, но движение рассматривается
    как двухстороннее. Нет разницы от старта к финишу двигаться или от финиша к
    старту. Возвращает список из стартовой точки, промежуточных точек и
    конечной точки, промежуточные точки не повторяются.

> any_multiway_optimal - все возможные пути аналогично any_way_optimal.

Маленькая ремарка - алгоритмы работают "в ширину", это не идеальный вариант 
если хочется получить максимальную скорость. В каждом примере можно найти вот 
такую строку "(way, start, steps) = queue.pop(0)" - она как раз и отвечает за 
поиск в ширину. Если удалить "0" из queue.pop ( "(way, start, steps) = queue.pop()" ), 
то алгоритм начнёт искать в глубину, это быстрее. 

В чём разница, почему в ширину, а не в глубину. При поиске в ширину происходит
поиск сначала самых коротких путей, а лишь потом уже всё более и более длинных.
Это связано с тем что на каждой итерации поиска глубина проверки для всех 
возможных вариантов одинаковая и постепенно увеличивается с каждым шагом.

При поиске в глубину, как ясно из названия, происходит перебор с последнего в 
очереди подходящего значения и далее точно так же, пока либо не будет достигнут
целевой пункт, либо пока не останется вариантов и данная очередь не будет 
просто удалена из списка. Этот вариант расходует меньше памяти и не 
переписывает каждый раз все элементы списка сдвигая их на один назад. Работает 
значительно быстрее, но не гарантирует минимального расстояния до цели.

Названия функций:

> one - это значит что будет выдан только первый найденный маршрут. Остальные 
> будут пропущены и забыты. 

> multi - это значит что будут выданы все возможные варианты маршрутов. Сделаны 
> они в варианте генераторов и могут быть легко конвертированы в one функции 
> просто получением первого элемента помощью встроенного метода next(...<генератор>).
> > Если генераторы вас каким-либо образом не устраивают - просто 
> > раскомментируйте все закоментированные строки и наоборот - закомментируйте 
> > строку с yield. После этого вы получите ответ списком всех возможных вариантов. 

> any - направление поиска любое, как вперёд так и назад. Тоесть если в списке 
> городов будут дступны пункты ('A', 'B'), ('C', 'B'), ('D', 'C'), то маршрут 
> A -> D будет найден такой: ('A', 'B'), ('B', 'C'), ('C', 'D') или такой: A, B, 
> C, D (вы зависимости от применённого метода.)
 
> optimal - оптимизирован поиск таким образом, что бы в маршрут не попадали уже 
> найденные варианты. Изменён вывод на простое перечисление пунктов начиная со 
> стартового, через все промежуточные и завершая конечным.
> > Если данная опция отсутствует - в списке найденных маршрутов вполне могут 
> > появляться повторные посещения пройденных ранее точек, но уже иными путями.

По сути это решение: задачи коммивояжёра, в самом примитивном случае, без каких 
либо оптимизаций. Не забывайте что если вы решите загрузить в неё несколько
сотен городов и построить все возможные маршруты, то как минимум, вам может не
хватить оперативной памяти и лучше в таком варианте всё же искать в глубину 
дабы найти ну хоть какой-то маршрут.

Сложность алгоритма O(N!) для всех вариантов. Объём памяти занимаемый под 
задачу примерно O((N+1)!).

Если бы все эти города были реальными, я бы эту задачу решал по другому и за 
O(N^2) итераций. Я бы опирался на взаимные полярные координаты городов и 
возможности проехать из пункта "A" в пункт "B" используя фильтр по R*sin(A), 
где - R расстояние до какого-то города в списке, а A - угол от этого города до 
целевого города на карте. То есть я бы итерационно двигался в сторону цели, 
стараясь максимально приблизиться к нему на каждой итерации. Для этого мне 
необходимо было бы сначала перевести все координаты из декартовых в полярные 
для всех городов, а затем на каждой итерации искать оптимальный вариант 
движения. Тут возможен ряд оптимизаций, но к сожалению метод всё равно имеет 
сложность O(N^2).

По всем вопросам, замечаниям, дополнениям: [электронная почта](mailto:zhss.83@yandex.ru)
